use crate::game::*;
/*
0000000
00000000000
00001110000
00000100000
00000000000
01000000000
01100000000
01000000000
00000000000
00000000000
00000000000
00000000000
*/
pub const CITADELS_0: u128 = 0b00000000000000000000001110000000001000000000000000001000000000011000000000100000000000000000000000000000000000000000000000000000;

/*
0000000
00000000000
00000000000
00000000000
00000000000
00000000010
00000000110
00000000010
00000000000
00000100000
00001110000
00000000000
*/
pub const CITADELS_1: u128 = 0b00000000000000000000000000000000000000000000000000000000000010000000001100000000001000000000000000001000000000111000000000000000;

/*
0000000
00000000000
00001110000
00000100000
00000000000
01000000010
01100000110
01000000010
00000000000
00000100000
00001110000
00000000000
*/
pub const START_A: u128 = 0b00000000000000000000001110000000001000000000000000001000000010011000001100100000001000000000000000001000000000111000000000000000;

/*
0000000
00000000000
00000000000
00000000000
00000100000
00000100000
00011011000
00000100000
00000100000
00000000000
00000000000
00000000000
*/
pub const START_D: u128 = 0b00000000000000000000000000000000000000000000010000000000100000000110110000000010000000000100000000000000000000000000000000000000;

/*
0000000
00000000000
00000000000
00000000000
00000000000
00000000000
00000100000
00000000000
00000000000
00000000000
00000000000
00000000000
*/
pub const START_K: u128 = 0b00000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000;

/*
0000000
00000000000
00000000000
00000000000
00000000000
00000100000
00001110000
00000100000
00000000000
00000000000
00000000000
00000000000
*/
pub const K_SAFETY: u128 = 0b00000000000000000000000000000000000000000000000000000000100000000011100000000010000000000000000000000000000000000000000000000000;

/*
0000000
11111111111
10001110001
10000100001
10000000001
11000000011
11100100111
11000000011
10000000001
10000100001
10001110001
11111111111
*/
pub const BLOCK: u128 = 0b00000001111111111110001110001100001000011000000000111000000011111001001111100000001110000000001100001000011000111000111111111111;

/*
0000000
00000000000
00001010000
00000100000
00000000000
01000000010
00100100100
01000000010
00000000000
00000100000
00001010000
00000000000
*/
pub const CAPTURE_AID: u128 = 0b00000000000000000000001010000000001000000000000000001000000010001001001000100000001000000000000000001000000000101000000000000000;

/*
0000000
00000000000
00110001100
01000000010
01000000010
00000000000
00000000000
00000000000
01000000010
01000000010
00110001100
00000000000
*/
pub const GOAL: u128 = 0b00000000000000000000110001100010000000100100000001000000000000000000000000000000000001000000010010000000100011000110000000000000;

pub const MASKS: [u128; 129] = {
	let mut res = [
		1,
		2,
		4,
		8,
		16,
		32,
		64,
		128,
		256,
		512,
		1024,
		2048,
		4096,
		8192,
		16384,
		32768,
		65536,
		131072,
		262144,
		524288,
		1048576,
		2097152,
		4194304,
		8388608,
		16777216,
		33554432,
		67108864,
		134217728,
		268435456,
		536870912,
		1073741824,
		2147483648,
		4294967296,
		8589934592,
		17179869184,
		34359738368,
		68719476736,
		137438953472,
		274877906944,
		549755813888,
		1099511627776,
		2199023255552,
		4398046511104,
		8796093022208,
		17592186044416,
		35184372088832,
		70368744177664,
		140737488355328,
		281474976710656,
		562949953421312,
		1125899906842624,
		2251799813685248,
		4503599627370496,
		9007199254740992,
		18014398509481984,
		36028797018963968,
		72057594037927936,
		144115188075855872,
		288230376151711744,
		576460752303423488,
		1152921504606846976,
		2305843009213693952,
		4611686018427387904,
		9223372036854775808,
		18446744073709551616,
		36893488147419103232,
		73786976294838206464,
		147573952589676412928,
		295147905179352825856,
		590295810358705651712,
		1180591620717411303424,
		2361183241434822606848,
		4722366482869645213696,
		9444732965739290427392,
		18889465931478580854784,
		37778931862957161709568,
		75557863725914323419136,
		151115727451828646838272,
		302231454903657293676544,
		604462909807314587353088,
		1208925819614629174706176,
		2417851639229258349412352,
		4835703278458516698824704,
		9671406556917033397649408,
		19342813113834066795298816,
		38685626227668133590597632,
		77371252455336267181195264,
		154742504910672534362390528,
		309485009821345068724781056,
		618970019642690137449562112,
		1237940039285380274899124224,
		2475880078570760549798248448,
		4951760157141521099596496896,
		9903520314283042199192993792,
		19807040628566084398385987584,
		39614081257132168796771975168,
		79228162514264337593543950336,
		158456325028528675187087900672,
		316912650057057350374175801344,
		633825300114114700748351602688,
		1267650600228229401496703205376,
		2535301200456458802993406410752,
		5070602400912917605986812821504,
		10141204801825835211973625643008,
		20282409603651670423947251286016,
		40564819207303340847894502572032,
		81129638414606681695789005144064,
		162259276829213363391578010288128,
		324518553658426726783156020576256,
		649037107316853453566312041152512,
		1298074214633706907132624082305024,
		2596148429267413814265248164610048,
		5192296858534827628530496329220096,
		10384593717069655257060992658440192,
		20769187434139310514121985316880384,
		41538374868278621028243970633760768,
		83076749736557242056487941267521536,
		166153499473114484112975882535043072,
		332306998946228968225951765070086144,
		664613997892457936451903530140172288,
		1329227995784915872903807060280344576,
		2658455991569831745807614120560689152,
		5316911983139663491615228241121378304,
		10633823966279326983230456482242756608,
		21267647932558653966460912964485513216,
		42535295865117307932921825928971026432,
		85070591730234615865843651857942052864,
		170141183460469231731687303715884105728,
		0,
	];
	res
};
// a &= !(1u128<<p);
// a |= 1u128<<p;
// (a>>p)&1 != 0

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Tablut {
	pub a: u128,
	pub d: u128,
	pub k: u128,
	pub turn: u32,
	pub state: State,
}

impl Default for Tablut {
	fn default() -> Self {
		Tablut::new(true)
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Tile {
	E,
	A,
	D,
	K,
}
impl Tablut {
	pub fn get_board(&self) -> [[Tile; 9]; 9] {
		let mut ans = [[Tile::E; 9]; 9];
		for y in 0..9 {
			for x in 0..9 {
				let p = y * 11 + x + 12;
				if (self.a >> p) & 1 != 0 {
					ans[y][x] = Tile::A;
				} else if (self.d >> p) & 1 != 0 {
					ans[y][x] = Tile::D;
				} else if (self.k >> p) & 1 != 0 {
					ans[y][x] = Tile::K;
				}
			}
		}
		ans
	}
}

impl Game for Tablut {
	type M = (u8, u8);
	type S = Self;
	type R = Self;
	fn new(t: bool) -> Self {
		Tablut {
			a: START_A,
			d: START_D,
			k: START_K,
			turn: if t { 0 } else { 1 },
			state: State::Going,
		}
	}
	fn turn(&self) -> bool {
		self.turn & 1 == 0
	}

	fn get_moves(&self) -> Vec<Self::M> {
		let mut ans = Vec::<Self::M>::with_capacity(96);
		let mut allies = if self.turn() { self.d | self.k } else { self.a };
		let pawns = self.d | self.k | self.a;
		while allies != 0 {
			let p = allies.trailing_zeros() as u8;
			allies ^= 1u128 << p;
			let pass = !(if self.turn() {
				BLOCK
			} else if (CITADELS_0 >> p) & 1 != 0 {
				BLOCK ^ CITADELS_0
			} else if (CITADELS_1 >> p) & 1 != 0 {
				BLOCK ^ CITADELS_1
			} else {
				BLOCK
			} | pawns);

			let mut i = p as usize + 11;
			while pass & MASKS[i] != 0 {
				ans.push((p, i as u8));
				i += 11;
			}
			i = p as usize - 11;
			while pass & MASKS[i] != 0 {
				ans.push((p, i as u8));
				i -= 11;
			}

			let mut i = p + 1;
			let p1 = (pass >> i) as u32;
			for _ in 0..p1.trailing_ones() {
				ans.push((p, i));
				i += 1;
			}
			i = p - 1;
			let mut p1 = (pass >> (i - 8)) as u32;
			p1 |= !511;
			let iter = p1.leading_ones() - 23;
			for _ in 0..iter {
				ans.push((p, i));
				i -= 1;
			}
		}
		if ans.is_empty() {
			ans.push((0, 0));
		}
		ans
	}
	fn get_moves_sorted(&self) -> Vec<Self::M> {
		let mut ans = self.get_moves();
		ans.sort_unstable_by_key(|m| {
			const ORDI: [[u8; 9]; 2] = [
				// 0,1,2,3,4,5,6,7,8   // old order
				[9, 4, 5, 3, 6, 7, 2, 1, 0], // def, lower is better
				[9, 5, 2, 4, 3, 7, 1, 6, 0], // atk, lower is better
			];
			let dif = if m.0 > m.1 { m.0 - m.1 } else { m.1 - m.0 };
			let dist = if dif >= 11 { dif / 11 } else { dif };
			if self.turn() {
				if (self.k >> m.0) & 1 != 0 {
					ORDI[(self.turn & 1) as usize][dist as usize]
				} else {
					ORDI[(self.turn & 1) as usize][dist as usize] + 8
				}
			} else {
				if (self.k >> (m.1 + 1)) & 1 != 0
					|| (self.k >> (m.1 + 11)) & 1 != 0
					|| (self.k >> (m.1 - 1)) & 1 != 0
					|| (self.k >> (m.1 - 11)) & 1 != 0
				{
					ORDI[(self.turn & 1) as usize][dist as usize]
				} else {
					ORDI[(self.turn & 1) as usize][dist as usize] + 8
				}
			}
		});
		ans
	}
	fn get_static_state(&self) -> Self::S {
		*self
	}
	fn state(&self) -> State {
		self.state
	}
	fn mov(&mut self, m: &Self::M) {
		if m.0 == 0 {
			self.state = if self.turn() { State::Win } else { State::Lose };
			return;
		}
		if self.turn() {
			// def
			if (self.d >> m.0) & 1 != 0 {
				// d moved
				self.d &= !(1u128 << m.0);
				self.d |= 1u128 << m.1;
			} else {
				// k moved
				self.k &= !(1u128 << m.0);
				self.k |= 1u128 << m.1;
			}
			let capturers = self.d | self.k | CAPTURE_AID;
			if (capturers >> (m.1 + 2)) & 1 != 0 {
				self.a &= !(1u128 << (m.1 + 1));
			}
			if (capturers >> (m.1 + 22)) & 1 != 0 {
				self.a &= !(1u128 << (m.1 + 11));
			}
			if (capturers >> (m.1 - 2)) & 1 != 0 {
				self.a &= !(1u128 << (m.1 - 1));
			}
			if (capturers >> (m.1 - 22)) & 1 != 0 {
				self.a &= !(1u128 << (m.1 - 11));
			}
		} else {
			// atk
			self.a &= !(1u128 << m.0);
			self.a |= 1u128 << m.1;
			let capturers = self.a | CAPTURE_AID;
			if (capturers >> (m.1 + 2)) & 1 != 0 {
				self.d &= !(1u128 << (m.1 + 1));
			}
			if (capturers >> (m.1 + 22)) & 1 != 0 {
				self.d &= !(1u128 << (m.1 + 11));
			}
			if (capturers >> (m.1 - 2)) & 1 != 0 {
				self.d &= !(1u128 << (m.1 - 1));
			}
			if (capturers >> (m.1 - 22)) & 1 != 0 {
				self.d &= !(1u128 << (m.1 - 11));
			}
			let sides =
				(1u128 << (m.1 + 1)) | (1u128 << (m.1 + 11)) | (1u128 << (m.1 - 1)) | (1u128 << (m.1 - 11));
			if self.k & sides != 0 {
				if self.k & K_SAFETY != 0 {
					let kp = self.k.trailing_zeros();
					let ksides =
						(1u128 << (kp + 1)) | (1u128 << (kp + 11)) | (1u128 << (kp - 1)) | (1u128 << (kp - 11));
					if (capturers & ksides).count_ones() == 4 {
						self.k = 0;
					}
				} else {
					if (capturers >> (m.1 + 2)) & 1 != 0 {
						self.k &= !(1u128 << (m.1 + 1));
					}
					if (capturers >> (m.1 + 22)) & 1 != 0 {
						self.k &= !(1u128 << (m.1 + 11));
					}
					if (capturers >> (m.1 - 2)) & 1 != 0 {
						self.k &= !(1u128 << (m.1 - 1));
					}
					if (capturers >> (m.1 - 22)) & 1 != 0 {
						self.k &= !(1u128 << (m.1 - 11));
					}
				}
			}
		}
		self.turn += 1;
		self.state = if self.k == 0 {
			State::Lose
		} else if self.k & GOAL != 0 {
			State::Win
		} else {
			State::Going
		}
	}
	fn mov_with_rollback(&mut self, m: &Self::M) -> Self::R {
		let t = *self;
		self.mov(m);
		t
	}
	fn rollback(&mut self, rbf: Self::R) {
		*self = rbf;
	}
}
impl std::fmt::Display for Tablut {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		for y in 1..10 {
			for x in 1..10 {
				let p = y * 11 + x;
				if (self.a >> p) & 1 != 0 {
					write!(f, "A")?;
				} else if (self.d >> p) & 1 != 0 {
					write!(f, "D")?;
				} else if (self.k >> p) & 1 != 0 {
					write!(f, "K")?;
				} else if (BLOCK >> p) & 1 != 0 {
					write!(f, ",")?;
				} else {
					write!(f, ".")?;
				}
			}
			writeln!(f)?;
		}
		Ok(())
	}
}
